function [traj,flag_t] = al_ilqr(traj,obj,t_clim)

% Unpack Variables
X = traj.x_br;
U = traj.u_br;
L = traj.L_br;
N = size(X,2);

% Initialize Sample Array
L_samp = zeros(2,10);

% Iteration Tuning Parameters
tol_motor = 1e-3;
tol_gate  = 5e-3;
phi       = [2 ; 15];

% LQR Parameters
lqr.N  = N;
% lqr.Xs = repmat([obj.kf.x(:,2);zeros(7,1)],1,N);
lqr.Qn = [
    0.00000.*ones(3,1) ;      % position
    0.00000.*ones(3,1) ;      % velocity
    0.00000.*ones(4,1) ;      % quaternion
    0.00000.*ones(2,1) ;      % err xy
    0.00000.*ones(1,1) ;      % err z
    0.00000.*ones(4,1)];      % err quat    
lqr.Rn = [
    0.00000.*ones(1,1) ;      % normalized thrust
    0.00000.*ones(3,1) ];     % body rate
lqr.QN = [
    1.00000.*ones(3,1) ;      % position
    1.00000.*ones(3,1) ;      % velocity
    0.00000.*ones(4,1) ;      % quaternion
    0.00000.*ones(2,1) ;      % err xy
    0.00000.*ones(1,1) ;      % err z
    0.00000.*ones(4,1)];      % err quat    
lqr.Xs = X;     % pin to nominal
lqr.Us = U;     % pin to nominal

pose_gt = obj.kf.gt(2:8,1);
gt_dim  = obj.db(obj.kf.gt(1,1)).gt_dim;
map     = obj.map.lim;

% Initialize Constraints
con  = con_calc(X,U,pose_gt,gt_dim,map);

% Initialize Lagrange Multiplier Terms
mult = mult_init(con);

% Initialize Lagrangian
La_c = lagr_calc(X,U,X,U,lqr,con,mult);

% Initialize Counter
counter = [0 0 0];

tic
% Multiplier Loop
while true
    counter(1,1) = counter(1,1)+1;
    
    % iLQR Loop
    while true
        counter(1,2) = counter(1,2)+1;

        % Backward Pass
        [l,L,~] = backward_pass(X,U,lqr,con,mult,'slow');
        
        % Sampling Method %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        % Save the initial
        X_save = X;
        U_save = U;
        L_save = L;
        
        % Initialize Constants
        Xbar = X;
        Ubar = U;
        lqr.Xs = X;
        lqr.Us = U;
        
        % Initialize Comparison
        La_p = La_c;
        state = 0;
        
        % Iterate across candidates
        for k = 1:10
            % Generate alpha
            if k < 10
                alpha = 0.8^(k-1);
            else
                alpha = 0;
            end
            
            % Compute Candidate
            [X_cand,U_cand] = forward_pass(Xbar,Ubar,l,L,alpha);
            con_cand  = con_calc(X_cand,U_cand,pose_gt,gt_dim,map);
            mult = mult_check(con_cand,mult,0);
            La_cand = lagr_calc(X_cand,U_cand,Xbar,Ubar,lqr,con_cand,mult);

            % Compare candidate
            if (L_cand.con < La_p.con)
                if (state == 0)
                    % Going into descent! keep going.
                    La_p = L_cand;
                    state = -1;
                end
            elseif 
                % Worsened. keep going if not at the end
                if k < 10
                    La_p = L_cand;
                end
            end
        end
        % Line Search Loop
        La_p = La_c;
        
        for k = 1:10
            if k > 2
                if La_c.con > La_p.con
                    break
                end
                X = X_cand;
                U = U_cand;
                con = con_cand;
                La_c = La_cand;
            end
            
            
            
            

            
            % Debug
            nominal_plot(X,obj,30,'persp');
        end
%         % Debug
%         nominal_plot(X,obj,10,'nice');
        
        if flag_SM == 0
            break;
        else
            % Carry on.
        end
    end
%     % Debug
%     nominal_plot(X,obj,10,'persp');
    
    % Update Lagrangian
    mult = mult_update(mult,con,phi);
    La_c = lagr_calc(X,U,X,U,lqr,con,mult);
            
    if toc < t_clim
        if (check_outer(con,tol_motor,tol_gate) == true)
            % Constraints satisfied. Stop al-iLQR.
            flag_t = 0;
            break
        end
    else
        % Ran out of compute time.
        flag_t = 1;
        break
    end
    
end
    
% % Debug
% mthrust_debug(Umt); 

% Package the State and Input Terms
traj.x_br = X;
traj.u_br = U;

% Regenerate the full trajectory (with 'fake' last body rate frame).
traj.x_bar = [X(1:10,:) ; U(2:4,:) zeros(3,1)]; 

% Generate the feedback matrix
% % v1
% traj.L_br = L;

% % v2
% [~,traj.L_br,~] = backward_pass(X,U,lqr,con,mult,'slow');

% v3
lqr.Qn = [
    0.00100.*ones(3,1) ;      % position
    0.00000.*ones(3,1) ;      % velocity
    0.00000.*ones(1,1) ;      % q_scalar
    0.00100.*ones(3,1) ;      % q_vect
    0.02000.*ones(2,1) ;      % err xy
    0.01000.*ones(1,1) ;      % err z
    0.00000.*ones(4,1)];      % err quat   
lqr.QN = [
    1.000.*ones(3,1) ;        % position
    1.000.*ones(3,1) ;        % velocity
    0.0000.*ones(1,1) ;      % q_scalar
    0.0000.*ones(3,1) ;      % q_vect
    0.000.*ones(2,1) ;        % err xy
    0.000.*ones(1,1) ;        % err z
    0.000.*ones(4,1)];        % err quat   

mult = mult_init(con);
[~,traj.L_br,~] = backward_pass(X,U,lqr,con,mult,'slow');
