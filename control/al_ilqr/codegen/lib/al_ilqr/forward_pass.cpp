//
//  Academic License - for use in teaching, academic research, and meeting
//  course requirements at degree granting institutions only.  Not for
//  government, commercial, or other organizational use.
//
//  forward_pass.cpp
//
//  Code generation for function 'forward_pass'
//


// Include files
#include "forward_pass.h"
#include "con_calc.h"
#include "lagr_calc.h"
#include "rt_nonfinite.h"
#include <cmath>
#include <cstring>

// Function Definitions
void forward_pass(double X[6010], double U[2400], const double l[2400], const
                  double L[24000], double La_p_tot, const double lambda[14424],
                  const double mu[14424], const double xs[10], double *La_c_con,
                  double *La_c_tot, double con[14424], double con_x[144240],
                  double con_u[57600])
{
  static double mu_diag[14424];
  static double Xact[7813];
  static double Xfp[6010];
  double Ufp[2400];
  double b_expl_temp[601];
  double c_expl_temp[601];
  double expl_temp[601];
  double b_Xact[10];
  double b_br_Ki[9];
  double b_br_Kp[9];
  double br_Kd[9];
  double br_Ki[9];
  double br_Kp[9];
  double u_mt[4];
  double b[3];
  double br_e_I[3];
  double br_err_now[3];
  double br_err_prev[3];
  double c_br_Kp[3];
  double alpha;
  double t12;
  signed char br_tmp[9];

  //  Tuning Parameter
  alpha = 1.0;

  //  Unpack the relevant variables
  std::memset(&Xact[0], 0, 7813U * sizeof(double));
  std::memcpy(&Xact[0], &X[0], 10U * sizeof(double));
  Xact[10] = 0.0;
  Xact[11] = 0.0;
  Xact[12] = 0.0;
  std::memset(&Xfp[0], 0, 6010U * sizeof(double));
  std::memcpy(&Xfp[0], &X[0], 10U * sizeof(double));
  std::memset(&Ufp[0], 0, 2400U * sizeof(double));

  //  Forward pass assumes no external forces and noise
  int exitg1;
  do {
    int b_k;
    int br_Kp_tmp;
    int k;
    exitg1 = 0;

    //  Tuning Parameters
    for (k = 0; k < 9; k++) {
      br_tmp[k] = 0;
    }

    br_tmp[0] = 1;
    br_tmp[4] = 1;
    br_tmp[8] = 1;
    for (k = 0; k < 9; k++) {
      br_Kp_tmp = br_tmp[k];
      br_Kp[k] = 0.22 * static_cast<double>(br_Kp_tmp);
      br_Ki[k] = 0.001 * static_cast<double>(br_Kp_tmp);
      br_Kd[k] = 0.0001 * static_cast<double>(br_Kp_tmp);
    }

    //  br.Kp = [ 0.2 0.00 0.00 ;
    //            0.00 0.2 0.00 ;
    //            0.00 0.00 0.2];
    //  br.Ki = [ 0.0 0.00 0.00 ;
    //            0.00 0.0 0.00 ;
    //            0.00 0.00 0.0];
    //  br.Kd = [ 0.0000 0.0000 0.0000 ;
    //            0.0000 0.0000 0.0000 ;
    //            0.0000 0.0000 0.0000];
    //  Proportional Variables
    //  Integral Variables
    //  Derivative Variables
    br_e_I[0] = 0.0;
    br_err_prev[0] = 0.0;
    br_e_I[1] = 0.0;
    br_err_prev[1] = 0.0;
    br_e_I[2] = 0.0;
    br_err_prev[2] = 0.0;
    for (b_k = 0; b_k < 600; b_k++) {
      double b_br_err_now_tmp;
      double br_err_now_tmp;
      double c_br_err_now_tmp;
      double t13;
      double t82;
      for (k = 0; k < 10; k++) {
        b_Xact[k] = Xact[k + 13 * b_k] - X[k + 10 * b_k];
      }

      for (k = 0; k < 4; k++) {
        t12 = 0.0;
        for (br_Kp_tmp = 0; br_Kp_tmp < 10; br_Kp_tmp++) {
          t12 += L[(k + (br_Kp_tmp << 2)) + 40 * b_k] * b_Xact[br_Kp_tmp];
        }

        br_Kp_tmp = k + (b_k << 2);
        Ufp[br_Kp_tmp] = (U[br_Kp_tmp] + alpha * l[br_Kp_tmp]) + t12;
      }

      //  Unpack Some Stuff
      //  Calculate the error
      br_Kp_tmp = b_k << 2;
      br_err_now_tmp = Xact[13 * b_k + 10];
      br_err_now[0] = br_err_now_tmp - Ufp[br_Kp_tmp + 1];
      b_br_err_now_tmp = Xact[13 * b_k + 11];
      br_err_now[1] = b_br_err_now_tmp - Ufp[br_Kp_tmp + 2];
      c_br_err_now_tmp = Xact[13 * b_k + 12];
      br_err_now[2] = c_br_err_now_tmp - Ufp[br_Kp_tmp + 3];

      //  Calculate Proportional Term
      //  Calculate the Integral Term
      //  Calculate the Derivative Term
      for (k = 0; k < 3; k++) {
        if (std::abs(br_e_I[k]) < 999.0) {
          br_e_I[0] += br_err_now[0];
          br_e_I[1] += br_err_now[1];
          br_e_I[2] += br_err_now[2];
        }

        b[k] = br_err_now[k] - br_err_prev[k];
        br_err_prev[k] = br_err_now[k];
      }

      //  Compile the Output
      // FN2F
      //     F_OUT = FN2F(FN)
      //     This function was generated by the Symbolic Math Toolbox version 8.6. 
      //     14-Jul-2021 21:15:49
      for (k = 0; k < 9; k++) {
        b_br_Kp[k] = -br_Kp[k];
        b_br_Ki[k] = -br_Ki[k];
      }

      t12 = br_err_now[0];
      t13 = br_err_now[1];
      t82 = br_err_now[2];
      for (k = 0; k < 3; k++) {
        c_br_Kp[k] = (b_br_Kp[k] * t12 + b_br_Kp[k + 3] * t13) + b_br_Kp[k + 6] *
          t82;
      }

      t12 = br_e_I[0];
      t13 = br_e_I[1];
      t82 = br_e_I[2];
      for (k = 0; k < 3; k++) {
        br_err_now[k] = (b_br_Ki[k] * t12 + b_br_Ki[k + 3] * t13) + b_br_Ki[k +
          6] * t82;
      }

      for (k = 0; k < 9; k++) {
        b_br_Kp[k] = -br_Kd[k];
      }

      u_mt[0] = Ufp[br_Kp_tmp] * 21.0824;
      t12 = b[0];
      t13 = b[1];
      t82 = b[2];
      for (k = 0; k < 3; k++) {
        u_mt[k + 1] = (c_br_Kp[k] + br_err_now[k]) + ((b_br_Kp[k] * t12 +
          b_br_Kp[k + 3] * t13) + b_br_Kp[k + 6] * t82);
      }

      double a;
      double b_a;
      double c_Xact;
      double d_Xact;
      double e_Xact;
      double f_Xact;
      double t12_tmp;
      double t13_tmp;
      double t2;
      double t3;
      double t37;
      double t37_tmp;
      double t38;
      double t38_tmp;
      double t39;
      double t4;
      double t40;
      double t41;
      double t41_tmp;
      double t42;
      double t42_tmp;
      double t43;
      double t44;
      double t45;
      double t46;
      double t5;
      double t52;
      double t53;
      double t54;
      double t6;
      double t60;
      double t7;
      double t73;
      double t74;
      double t75;
      double t76;
      double t8;
      double t9;

      // W2M_EST
      //     U_M = W2M_EST(IN1)
      //     This function was generated by the Symbolic Math Toolbox version 8.6. 
      //     14-Jul-2021 21:15:49
      t2 = u_mt[0] * 42808.219178082189;
      t3 = u_mt[3] * 713470.31963470322;
      t5 = u_mt[1] * 483708.69127776491;
      t6 = u_mt[2] * 483708.69127776491;
      t12 = t2 + -t3;
      u_mt[0] = std::sqrt((t12 + -t5) + -t6);
      u_mt[1] = std::sqrt((t12 + t5) + t6);
      t12 = t2 + t3;
      u_mt[2] = std::sqrt((t12 + t5) + -t6);
      u_mt[3] = std::sqrt((t12 + t6) + -t5);

      // QUADCOPTER_EST
      //     X_UPD = QUADCOPTER_EST(IN1,IN2,IN3,IN4)
      //     This function was generated by the Symbolic Math Toolbox version 8.6. 
      //     14-Jul-2021 21:15:48
      c_Xact = Xact[13 * b_k + 6];
      t2 = c_Xact * c_Xact;
      d_Xact = Xact[13 * b_k + 7];
      t3 = d_Xact * d_Xact;
      e_Xact = Xact[13 * b_k + 8];
      t4 = e_Xact * e_Xact;
      f_Xact = Xact[13 * b_k + 9];
      t5 = f_Xact * f_Xact;
      t6 = u_mt[0] * u_mt[0];
      t7 = u_mt[1] * u_mt[1];
      t8 = u_mt[2] * u_mt[2];
      t9 = u_mt[3] * u_mt[3];
      t12_tmp = c_Xact * f_Xact;
      t12 = t12_tmp * 2.0;
      t13_tmp = d_Xact * e_Xact;
      t13 = t13_tmp * 2.0;
      t37_tmp = c_Xact * d_Xact;
      t37 = t37_tmp / 5.0E+8;
      t38_tmp = c_Xact * e_Xact;
      t38 = t38_tmp / 5.0E+8;
      t39 = t12_tmp / 5.0E+8;
      t40 = t13_tmp / 5.0E+8;
      t41_tmp = d_Xact * f_Xact;
      t41 = t41_tmp / 5.0E+8;
      t42_tmp = e_Xact * f_Xact;
      t42 = t42_tmp / 5.0E+8;
      t43 = t2 / 1.0E+9;
      t44 = t3 / 1.0E+9;
      t45 = t4 / 1.0E+9;
      t46 = t5 / 1.0E+9;
      t60 = ((-c_Xact + d_Xact * br_err_now_tmp / 200.0) + e_Xact *
             b_br_err_now_tmp / 200.0) + f_Xact * c_br_err_now_tmp / 200.0;
      t73 = t6 * 1.7760824742268041E-7;
      t74 = t7 * 1.7760824742268041E-7;
      t75 = t8 * 1.7760824742268041E-7;
      t76 = t9 * 1.7760824742268041E-7;
      t52 = ((d_Xact + c_Xact * br_err_now_tmp / 200.0) + e_Xact *
             c_br_err_now_tmp / 200.0) + -(f_Xact * b_br_err_now_tmp / 200.0);
      t53 = ((e_Xact + c_Xact * b_br_err_now_tmp / 200.0) + f_Xact *
             br_err_now_tmp / 200.0) + -(d_Xact * c_br_err_now_tmp / 200.0);
      t54 = ((f_Xact + c_Xact * c_br_err_now_tmp / 200.0) + d_Xact *
             b_br_err_now_tmp / 200.0) + -(e_Xact * br_err_now_tmp / 200.0);
      t82 = std::abs(t60);
      f_Xact = std::abs(t52);
      a = std::abs(t53);
      b_a = std::abs(t54);
      c_Xact = Xact[13 * b_k + 5];
      d_Xact = Xact[13 * b_k + 4];
      e_Xact = Xact[13 * b_k + 3];
      t12 = ((((t37_tmp * 2.0 + t41_tmp * 2.0) + t42_tmp * 2.0) + -(t38_tmp *
               2.0)) * c_Xact + (((((t2 + t4) + t12) + t13) + -t3) + -t5) *
             d_Xact) + e_Xact * (((((t2 + t3) - t4) - t12) + t13) + -t5);
      t82 = 1.0 / std::sqrt(((f_Xact * f_Xact + a * a) + b_a * b_a) + t82 * t82);
      t12 = (((t6 * 5.84E-6 + t7 * 5.84E-6) + t8 * 5.84E-6) + t9 * 5.84E-6) +
        t12 * t12 * 1.5E-9;
      f_Xact = Xact[13 * b_k + 1];
      t13 = Xact[13 * b_k + 2];
      br_Kp_tmp = 13 * (b_k + 1);
      Xact[br_Kp_tmp] = Xact[13 * b_k] + e_Xact / 100.0;
      Xact[br_Kp_tmp + 1] = f_Xact + d_Xact / 100.0;
      Xact[br_Kp_tmp + 2] = t13 + c_Xact / 100.0;
      Xact[br_Kp_tmp + 3] = ((((e_Xact - e_Xact * (((t43 + t44) + -t45) + -t46) /
        150.0) - c_Xact * (t38 + t41) / 150.0) + d_Xact * (t39 - t40) / 150.0) +
        t38_tmp * t12 / 75.0) + t41_tmp * t12 / 75.0;
      Xact[br_Kp_tmp + 4] = ((((d_Xact - d_Xact * (((t43 + t45) + -t44) + -t46) /
        150.0) - e_Xact * (t39 + t40) / 150.0) + c_Xact * (t37 - t42) / 150.0) -
        t37_tmp * t12 / 75.0) + t42_tmp * t12 / 75.0;
      Xact[br_Kp_tmp + 5] = (((((((c_Xact - c_Xact * (((t43 + t46) + -t44) +
        -t45) / 150.0) - d_Xact * (t37 + t42) / 150.0) + t2 * t12 / 150.0) - t3 *
        t12 / 150.0) - t4 * t12 / 150.0) + t5 * t12 / 150.0) + e_Xact * (t38 -
        t41) / 150.0) - 0.0981;
      Xact[br_Kp_tmp + 6] = 0.0 - t60 * t82;
      Xact[br_Kp_tmp + 7] = t52 * t82;
      Xact[br_Kp_tmp + 8] = t53 * t82;
      Xact[br_Kp_tmp + 9] = t54 * t82;
      Xact[br_Kp_tmp + 10] = ((((((((((((t74 + t75) - t76) + -t73) +
        br_err_now_tmp * 0.99999999965635744) - t2 * e_Xact / 2.91E+9) - t3 *
        e_Xact / 2.91E+9) + t4 * e_Xact / 2.91E+9) + t5 * e_Xact / 2.91E+9) -
        b_br_err_now_tmp * c_br_err_now_tmp * 0.008969072164948454) + t38_tmp *
        c_Xact / 1.455E+9) - t12_tmp * d_Xact / 1.455E+9) - t13_tmp * d_Xact /
        1.455E+9) - t41_tmp * c_Xact / 1.455E+9;
      Xact[br_Kp_tmp + 11] = ((((((((((((t74 - t75) + t76) + -t73) +
        b_br_err_now_tmp * 0.99999999965635744) - t2 * d_Xact / 2.91E+9) + t3 *
        d_Xact / 2.91E+9) - t4 * d_Xact / 2.91E+9) + t5 * d_Xact / 2.91E+9) +
        br_err_now_tmp * c_br_err_now_tmp * 0.008969072164948454) - t37_tmp *
        c_Xact / 1.455E+9) + t12_tmp * e_Xact / 1.455E+9) - t13_tmp * e_Xact /
        1.455E+9) - t42_tmp * c_Xact / 1.455E+9;
      Xact[br_Kp_tmp + 12] = (((((((((((t6 * -6.3478260869565226E-8 - t7 *
        6.3478260869565226E-8) + t8 * 6.3478260869565226E-8) + t9 *
        6.3478260869565226E-8) + c_br_err_now_tmp * 0.99999999981884058) - t2 *
        c_Xact / 5.52E+9) + t3 * c_Xact / 5.52E+9) + t4 * c_Xact / 5.52E+9) - t5
        * c_Xact / 5.52E+9) + t37_tmp * d_Xact / 2.76E+9) - t38_tmp * e_Xact /
        2.76E+9) - t41_tmp * e_Xact / 2.76E+9) - t42_tmp * d_Xact / 2.76E+9;
      std::memcpy(&Xfp[b_k * 10 + 10], &Xact[br_Kp_tmp], 10U * sizeof(double));
    }

    con_calc(Xfp, Ufp, con, con_x, con_u);
    std::memset(&mu_diag[0], 0, 14424U * sizeof(double));
    for (b_k = 0; b_k < 601; b_k++) {
      for (br_Kp_tmp = 0; br_Kp_tmp < 24; br_Kp_tmp++) {
        k = br_Kp_tmp + 24 * b_k;
        if ((!(con[k] <= 0.0)) || (!(lambda[k] == 0.0))) {
          //  Constraint violated. Turn on Augment.
          mu_diag[k] = mu[k];
        } else {
          //  Constraint not violated. Carry on.
        }
      }
    }

    std::memcpy(&b_Xact[0], &xs[0], 10U * sizeof(double));
    lagr_calc(Xfp, b_Xact, con, lambda, mu_diag, expl_temp, b_expl_temp,
              c_expl_temp, &t12, La_c_con, La_c_tot);

    //  Debug
    //      La_plot(La_p,La_c);
    //     nominal_plot(Xact,map,10,'nice');
    //      disp(['[forward_pass]: alpha = ',num2str(alpha)]);
    t12 = La_p_tot - *La_c_tot;
    br_Kp_tmp = 999;
    if (t12 > 0.0) {
      //  Line-Search Gain Valid
      br_Kp_tmp = 0;
    } else {
      if (t12 < -100.0) {
        //  Trajectory Exploded. Generate an 'empty' update
        br_Kp_tmp = 2;
      }

      if (alpha > 0.3) {
        //  Line-Search Gain Invalid
        br_Kp_tmp = 1;
        alpha *= 0.5;
      } else {
        if ((alpha < 0.3) && (alpha > 0.0)) {
          //  Alpha Too Small. Generate an 'empty' update
          br_Kp_tmp = 2;
        }
      }
    }

    if (br_Kp_tmp == 0) {
      std::memcpy(&X[0], &Xfp[0], 6010U * sizeof(double));
      std::memcpy(&U[0], &Ufp[0], 2400U * sizeof(double));
      exitg1 = 1;
    } else if ((br_Kp_tmp != 1) && (br_Kp_tmp == 2)) {
      //  Rever to Old
      exitg1 = 1;
    } else {
      //  Carry On
    }
  } while (exitg1 == 0);
}

// End of code generation (forward_pass.cpp)
