//
//  Academic License - for use in teaching, academic research, and meeting
//  course requirements at degree granting institutions only.  Not for
//  government, commercial, or other organizational use.
//
//  backward_pass.cpp
//
//  Code generation for function 'backward_pass'
//


// Include files
#include "backward_pass.h"
#include "mldivide.h"
#include "rcond.h"
#include "rt_nonfinite.h"
#include "xzgetrf.h"
#include "rt_nonfinite.h"
#include <cmath>
#include <cstring>

// Function Declarations
static double rt_powd_snf(double u0, double u1);

// Function Definitions
static double rt_powd_snf(double u0, double u1)
{
  double y;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else {
    double d;
    double d1;
    d = std::abs(u0);
    d1 = std::abs(u1);
    if (rtIsInf(u1)) {
      if (d == 1.0) {
        y = 1.0;
      } else if (d > 1.0) {
        if (u1 > 0.0) {
          y = rtInf;
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = rtInf;
      }
    } else if (d1 == 0.0) {
      y = 1.0;
    } else if (d1 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = rtNaN;
    } else {
      y = std::pow(u0, u1);
    }
  }

  return y;
}

void backward_pass(const double X[6010], const double U[2400], const double con
                   [14424], const double con_x[144240], const double con_u[57600],
                   const double lambda[14424], const double mu_diag[14424],
                   double xs[10], double l[2400], double L[24000], double delV
                   [1202])
{
  static const signed char Q_N[100] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 1 };

  double I_mu[576];
  double c_y_tmp[240];
  double f_y_tmp[240];
  double A[100];
  double V[100];
  double b_y_tmp[100];
  double e_y_tmp[100];
  double d_Quu_tmp[96];
  double d_y_tmp[96];
  double Qux[40];
  double b_Qux[40];
  double c_Quu_tmp[40];
  double y_tmp[40];
  double Qx_tmp[24];
  double Quu[16];
  double Quu_tmp[16];
  double b_Quu_tmp[16];
  double reg[16];
  double dv[10];
  double in2[10];
  double q_N[10];
  double Qu[4];
  double d;
  double d1;
  double rho;
  double t104;
  double t111_tmp;
  double t68;
  int ipiv[4];
  int i;
  int j;

  //  Unpack some useful stuff
  //  Generate the nominals and ideals (Xstar, Ustar)
  //  Tuning Parameter
  rho = 0.001;
  std::memset(&reg[0], 0, 16U * sizeof(double));

  //  Initialize feedback policy variables
  std::memset(&l[0], 0, 2400U * sizeof(double));
  std::memset(&L[0], 0, 24000U * sizeof(double));
  std::memset(&delV[0], 0, 1202U * sizeof(double));

  //  Initial
  std::memcpy(&in2[0], &xs[0], 10U * sizeof(double));

  // Q_N_CALC
  //     Q_N = Q_N_CALC(IN1,IN2)
  //     This function was generated by the Symbolic Math Toolbox version 8.6.
  //     14-Jul-2021 21:15:56
  q_N[0] = X[6000] - in2[0];
  q_N[1] = X[6001] - in2[1];
  q_N[2] = X[6002] - in2[2];
  q_N[3] = X[6003] - in2[3];
  q_N[4] = X[6004] - in2[4];
  q_N[5] = X[6005] - in2[5];
  q_N[6] = X[6006] - in2[6];
  q_N[7] = X[6007] - in2[7];
  q_N[8] = X[6008] - in2[8];
  q_N[9] = X[6009] - in2[9];
  for (i = 0; i < 100; i++) {
    V[i] = Q_N[i];
  }

  for (int k = 0; k < 600; k++) {
    double A_tmp;
    double b_A_tmp;
    double b_t111_tmp;
    double c_A_tmp;
    double c_t111_tmp;
    double d2;
    double d3;
    double d_t111_tmp;
    double t100;
    double t101;
    double t103;
    double t105;
    double t106;
    double t107;
    double t111;
    double t112;
    double t114;
    double t22;
    double t23;
    double t24;
    double t27;
    double t29;
    double t30;
    double t31;
    double t32;
    double t33;
    double t35;
    double t36;
    double t37;
    double t38;
    double t38_tmp;
    double t40;
    double t40_tmp;
    double t41;
    double t46;
    double t46_tmp;
    double t47;
    double t47_tmp;
    double t48;
    double t48_tmp;
    double t58;
    double t59;
    double t59_tmp;
    double t60;
    double t60_tmp;
    double t61;
    double t61_tmp;
    double t62_tmp;
    double t63_tmp;
    double t64_tmp;
    double t65_tmp;
    double t66_tmp;
    double t67_tmp;
    double t69;
    double t70;
    double t71_tmp;
    double t72_tmp;
    double t76;
    double t98;
    double t99;
    int i1;
    int i2;
    int l_tmp;
    int y_tmp_tmp;

    //  Unpack stagewise stuff
    // A_CALC
    //     A = A_CALC(IN1,IN2)
    //     This function was generated by the Symbolic Math Toolbox version 8.6. 
    //     14-Jul-2021 21:15:52
    l_tmp = (599 - k) << 2;
    t111_tmp = U[l_tmp];
    i = 10 * (599 - k);
    d = X[i + 6];
    t22 = t111_tmp * d * 0.28109866666666672;
    d1 = X[i + 7];
    t23 = t111_tmp * d1 * 0.28109866666666672;
    d2 = X[i + 8];
    t24 = t111_tmp * d2 * 0.28109866666666672;
    t68 = X[i + 3];
    t27 = t68 * d / 7.5E+10;
    t70 = X[i + 4];
    t29 = t70 * d / 7.5E+10;
    t30 = t68 * d2 / 7.5E+10;
    t31 = t70 * d1 / 7.5E+10;
    t69 = X[i + 5];
    t32 = t69 * d / 7.5E+10;
    d3 = X[i + 9];
    t33 = t68 * d3 / 7.5E+10;
    t35 = t69 * d1 / 7.5E+10;
    t36 = t70 * d3 / 7.5E+10;
    t37 = t69 * d2 / 7.5E+10;
    t38_tmp = d * d1;
    t38 = t38_tmp / 7.5E+10;
    t40_tmp = d * d2;
    t40 = t40_tmp / 7.5E+10;
    t41 = d * d3 / 7.5E+10;
    t46_tmp = d1 * d1;
    t46 = t46_tmp / 1.5E+11;
    t47_tmp = d2 * d2;
    t47 = t47_tmp / 1.5E+11;
    t48_tmp = d3 * d3;
    t48 = t48_tmp / 1.5E+11;
    t58 = -(d1 * d2 / 7.5E+10);
    t59_tmp = d1 * d3;
    t59 = -(t59_tmp / 7.5E+10);
    t60_tmp = d2 * d3;
    t60 = -(t60_tmp / 7.5E+10);
    A_tmp = U[l_tmp + 1];
    b_A_tmp = U[l_tmp + 2];
    c_A_tmp = U[l_tmp + 3];
    t71_tmp = ((-d + A_tmp * d1 / 200.0) + b_A_tmp * d2 / 200.0) + c_A_tmp * d3 /
      200.0;
    t61_tmp = d * d;
    t61 = -(t61_tmp / 1.5E+11);
    t62_tmp = ((A_tmp * d / 200.0 + c_A_tmp * d2 / 200.0) + -(b_A_tmp * d3 /
                200.0)) + d1;
    t63_tmp = ((b_A_tmp * d / 200.0 + A_tmp * d3 / 200.0) + -(c_A_tmp * d1 /
                200.0)) + d2;
    t64_tmp = ((b_A_tmp * d1 / 200.0 + c_A_tmp * d / 200.0) + -(A_tmp * d2 /
                200.0)) + d3;
    t72_tmp = std::abs(t71_tmp);
    t76 = t71_tmp;
    if (t71_tmp < 0.0) {
      t76 = -1.0;
    } else if (t71_tmp > 0.0) {
      t76 = 1.0;
    } else {
      if (t71_tmp == 0.0) {
        t76 = 0.0;
      }
    }

    t98 = ((t22 + t30) + -t31) + -t32;
    t99 = ((t24 + t36) + -t27) + -t37;
    t100 = ((-t23 + t35) + -t29) + -t33;
    t101 = ((t111_tmp * d3 * 0.28109866666666672 + -(t68 * d1 / 7.5E+10)) +
            -(t70 * d2 / 7.5E+10)) + -(t69 * d3 / 7.5E+10);
    t65_tmp = std::abs(t62_tmp);
    t66_tmp = std::abs(t63_tmp);
    t67_tmp = std::abs(t64_tmp);
    t68 = t62_tmp;
    if (t62_tmp < 0.0) {
      t68 = -1.0;
    } else if (t62_tmp > 0.0) {
      t68 = 1.0;
    } else {
      if (t62_tmp == 0.0) {
        t68 = 0.0;
      }
    }

    t69 = t63_tmp;
    if (t63_tmp < 0.0) {
      t69 = -1.0;
    } else if (t63_tmp > 0.0) {
      t69 = 1.0;
    } else {
      if (t63_tmp == 0.0) {
        t69 = 0.0;
      }
    }

    t70 = t64_tmp;
    if (t64_tmp < 0.0) {
      t70 = -1.0;
    } else if (t64_tmp > 0.0) {
      t70 = 1.0;
    } else {
      if (t64_tmp == 0.0) {
        t70 = 0.0;
      }
    }

    b_t111_tmp = t65_tmp * t68;
    c_t111_tmp = t67_tmp * t70;
    d_t111_tmp = t66_tmp * t69;
    t111_tmp = t72_tmp * t76;
    t111 = ((b_t111_tmp * A_tmp / 100.0 + d_t111_tmp * b_A_tmp / 100.0) +
            c_t111_tmp * c_A_tmp / 100.0) + -(t111_tmp * 2.0);
    t103 = 1.0 / std::sqrt(((t65_tmp * t65_tmp + t66_tmp * t66_tmp) + t67_tmp *
      t67_tmp) + t72_tmp * t72_tmp);
    t112 = ((b_t111_tmp * 2.0 + c_t111_tmp * b_A_tmp / 100.0) + -(d_t111_tmp *
             c_A_tmp / 100.0)) + t111_tmp * A_tmp / 100.0;
    t70 = ((d_t111_tmp * 2.0 + b_t111_tmp * c_A_tmp / 100.0) + -(c_t111_tmp *
            A_tmp / 100.0)) + t111_tmp * b_A_tmp / 100.0;
    t114 = ((c_t111_tmp * 2.0 + d_t111_tmp * A_tmp / 100.0) + -(b_t111_tmp *
             b_A_tmp / 100.0)) + t111_tmp * c_A_tmp / 100.0;
    t104 = rt_powd_snf(t103, 3.0);
    t105 = t103 * A_tmp / 200.0;
    t106 = t103 * b_A_tmp / 200.0;
    t107 = t103 * c_A_tmp / 200.0;
    A[0] = 1.0;
    std::memset(&A[1], 0, 10U * sizeof(double));
    A[11] = 1.0;
    std::memset(&A[12], 0, 10U * sizeof(double));
    A[22] = 1.0;
    A[23] = 0.0;
    A[24] = 0.0;
    A[25] = 0.0;
    A[26] = 0.0;
    A[27] = 0.0;
    A[28] = 0.0;
    A[29] = 0.0;
    A[30] = 0.01;
    A[31] = 0.0;
    A[32] = 0.0;
    A[33] = (((-t46 + t47) + t48) + t61) + 1.0;
    A[34] = -t41 + t58;
    A[35] = t40 + t59;
    A[36] = 0.0;
    A[37] = 0.0;
    A[38] = 0.0;
    A[39] = 0.0;
    A[40] = 0.0;
    A[41] = 0.01;
    A[42] = 0.0;
    A[43] = t41 + t58;
    A[44] = (((t46 - t47) + t48) + t61) + 1.0;
    A[45] = -t38 + t60;
    A[46] = 0.0;
    A[47] = 0.0;
    A[48] = 0.0;
    A[49] = 0.0;
    A[50] = 0.0;
    A[51] = 0.0;
    A[52] = 0.01;
    A[53] = -t40 + t59;
    A[54] = t38 + t60;
    A[55] = (((t46 + t47) - t48) + t61) + 1.0;
    A[56] = 0.0;
    A[57] = 0.0;
    A[58] = 0.0;
    A[59] = 0.0;
    A[60] = 0.0;
    A[61] = 0.0;
    A[62] = 0.0;
    A[63] = t99;
    A[64] = t100;
    A[65] = t98;
    t68 = t71_tmp * t104;
    A[66] = t103 + t68 * t111 / 2.0;
    b_A_tmp = t62_tmp * t104;
    A[67] = t105 - b_A_tmp * t111 / 2.0;
    c_A_tmp = t63_tmp * t104;
    A[68] = t106 - c_A_tmp * t111 / 2.0;
    A_tmp = t64_tmp * t104;
    A[69] = t107 - A_tmp * t111 / 2.0;
    A[70] = 0.0;
    A[71] = 0.0;
    A[72] = 0.0;
    A[73] = t101;
    A[74] = ((-t22 - t30) + t31) + t32;
    A[75] = t100;
    A[76] = -t105 + t68 * t112 / 2.0;
    A[77] = t103 - b_A_tmp * t112 / 2.0;
    A[78] = -t107 - c_A_tmp * t112 / 2.0;
    A[79] = t106 - A_tmp * t112 / 2.0;
    A[80] = 0.0;
    A[81] = 0.0;
    A[82] = 0.0;
    A[83] = t98;
    A[84] = t101;
    A[85] = ((-t24 + t27) - t36) + t37;
    A[86] = -t106 + t68 * t70 / 2.0;
    A[87] = t107 - b_A_tmp * t70 / 2.0;
    A[88] = t103 - c_A_tmp * t70 / 2.0;
    A[89] = -t105 - A_tmp * t70 / 2.0;
    A[90] = 0.0;
    A[91] = 0.0;
    A[92] = 0.0;
    A[93] = ((t23 + t29) + t33) - t35;
    A[94] = t99;
    A[95] = t101;
    A[96] = -t107 + t68 * t114 / 2.0;
    A[97] = -t106 - b_A_tmp * t114 / 2.0;
    A[98] = t105 - c_A_tmp * t114 / 2.0;
    A[99] = t103 - A_tmp * t114 / 2.0;

    // B_CALC
    //     B = B_CALC(IN1,IN2)
    //     This function was generated by the Symbolic Math Toolbox version 8.6. 
    //     14-Jul-2021 21:15:52
    t32 = t71_tmp;
    if (t71_tmp < 0.0) {
      t32 = -1.0;
    } else if (t71_tmp > 0.0) {
      t32 = 1.0;
    } else {
      if (t71_tmp == 0.0) {
        t32 = 0.0;
      }
    }

    t24 = t62_tmp;
    if (t62_tmp < 0.0) {
      t24 = -1.0;
    } else if (t62_tmp > 0.0) {
      t24 = 1.0;
    } else {
      if (t62_tmp == 0.0) {
        t24 = 0.0;
      }
    }

    t68 = t63_tmp;
    if (t63_tmp < 0.0) {
      t68 = -1.0;
    } else if (t63_tmp > 0.0) {
      t68 = 1.0;
    } else {
      if (t63_tmp == 0.0) {
        t68 = 0.0;
      }
    }

    t69 = t64_tmp;
    if (t64_tmp < 0.0) {
      t69 = -1.0;
    } else if (t64_tmp > 0.0) {
      t69 = 1.0;
    } else {
      if (t64_tmp == 0.0) {
        t69 = 0.0;
      }
    }

    t105 = 1.0 / std::sqrt(((t65_tmp * t65_tmp + t66_tmp * t66_tmp) + t67_tmp *
      t67_tmp) + t72_tmp * t72_tmp);
    t76 = t66_tmp * t68;
    c_t111_tmp = t67_tmp * t69;
    b_A_tmp = t65_tmp * t24;
    t68 = t72_tmp * t32;
    t59 = ((b_A_tmp * d / 100.0 + t76 * d3 / 100.0) + -(c_t111_tmp * d2 / 100.0))
      + t68 * d1 / 100.0;
    t60 = ((t76 * d / 100.0 + c_t111_tmp * d1 / 100.0) + -(b_A_tmp * d3 / 100.0))
      + t68 * d2 / 100.0;
    t61 = ((c_t111_tmp * d / 100.0 + b_A_tmp * d2 / 100.0) + -(t76 * d1 / 100.0))
      + t68 * d3 / 100.0;
    t104 = rt_powd_snf(t105, 3.0);
    t112 = t105 * d / 200.0;
    t103 = t105 * d1 / 200.0;
    t111 = t105 * d2 / 200.0;
    t114 = t105 * d3 / 200.0;
    std::memset(&I_mu[0], 0, 576U * sizeof(double));
    for (j = 0; j < 24; j++) {
      I_mu[j + 24 * j] = mu_diag[j + 24 * (599 - k)];
    }

    //  Generate Intermediate Terms
    for (i = 0; i < 24; i++) {
      t111_tmp = 0.0;
      for (i1 = 0; i1 < 24; i1++) {
        t111_tmp += I_mu[i + 24 * i1] * con[i1 + 24 * (599 - k)];
      }

      Qx_tmp[i] = lambda[i + 24 * (599 - k)] + t111_tmp;
    }

    for (i = 0; i < 10; i++) {
      for (i1 = 0; i1 < 10; i1++) {
        b_y_tmp[i1 + 10 * i] = A[i + 10 * i1];
      }
    }

    y_tmp[0] = 0.0;
    y_tmp[4] = 0.0;
    y_tmp[8] = 0.0;
    t106 = t40_tmp * 0.28109866666666672 + t59_tmp * 0.28109866666666672;
    y_tmp[12] = t106;
    b_t111_tmp = t38_tmp * -0.28109866666666672 + t60_tmp * 0.28109866666666672;
    y_tmp[16] = b_t111_tmp;
    t107 = ((t61_tmp * 0.1405493333333333 - t46_tmp * 0.1405493333333333) -
            t47_tmp * 0.1405493333333333) + t48_tmp * 0.1405493333333333;
    y_tmp[20] = t107;
    y_tmp[24] = 0.0;
    y_tmp[28] = 0.0;
    y_tmp[32] = 0.0;
    y_tmp[36] = 0.0;
    y_tmp[1] = 0.0;
    y_tmp[5] = 0.0;
    y_tmp[9] = 0.0;
    y_tmp[13] = 0.0;
    y_tmp[17] = 0.0;
    y_tmp[21] = 0.0;
    t111_tmp = t71_tmp * t104;
    d_t111_tmp = -t103 + t111_tmp * t59 / 2.0;
    y_tmp[25] = d_t111_tmp;
    c_A_tmp = t62_tmp * t104;
    t70 = t112 - c_A_tmp * t59 / 2.0;
    y_tmp[29] = t70;
    t105 = t63_tmp * t104;
    A_tmp = t114 - t105 * t59 / 2.0;
    y_tmp[33] = A_tmp;
    t104 *= t64_tmp;
    b_A_tmp = -t111 - t104 * t59 / 2.0;
    y_tmp[37] = b_A_tmp;
    y_tmp[2] = 0.0;
    y_tmp[6] = 0.0;
    y_tmp[10] = 0.0;
    y_tmp[14] = 0.0;
    y_tmp[18] = 0.0;
    y_tmp[22] = 0.0;
    t69 = -t111 + t111_tmp * t60 / 2.0;
    y_tmp[26] = t69;
    c_t111_tmp = -t114 - c_A_tmp * t60 / 2.0;
    y_tmp[30] = c_t111_tmp;
    t76 = t112 - t105 * t60 / 2.0;
    y_tmp[34] = t76;
    t68 = t103 - t104 * t60 / 2.0;
    y_tmp[38] = t68;
    y_tmp[3] = 0.0;
    y_tmp[7] = 0.0;
    y_tmp[11] = 0.0;
    y_tmp[15] = 0.0;
    y_tmp[19] = 0.0;
    y_tmp[23] = 0.0;
    t111_tmp = -t114 + t111_tmp * t61 / 2.0;
    y_tmp[27] = t111_tmp;
    c_A_tmp = t111 - c_A_tmp * t61 / 2.0;
    y_tmp[31] = c_A_tmp;
    t105 = -t103 - t105 * t61 / 2.0;
    y_tmp[35] = t105;
    t104 = t112 - t104 * t61 / 2.0;
    y_tmp[39] = t104;
    for (i = 0; i < 24; i++) {
      for (i1 = 0; i1 < 10; i1++) {
        c_y_tmp[i1 + 10 * i] = con_x[(i + 24 * i1) + 240 * (599 - k)];
      }

      j = i + 96 * (599 - k);
      y_tmp_tmp = i << 2;
      d_y_tmp[y_tmp_tmp] = con_u[j];
      d_y_tmp[y_tmp_tmp + 1] = con_u[j + 24];
      d_y_tmp[y_tmp_tmp + 2] = con_u[j + 48];
      d_y_tmp[y_tmp_tmp + 3] = con_u[j + 72];
    }

    Qux[0] = 0.0;
    Qux[1] = 0.0;
    Qux[2] = 0.0;
    Qux[3] = t106;
    Qux[4] = b_t111_tmp;
    Qux[5] = t107;
    std::memset(&Qux[6], 0, 10U * sizeof(double));
    Qux[16] = d_t111_tmp;
    Qux[17] = t70;
    Qux[18] = A_tmp;
    Qux[19] = b_A_tmp;
    Qux[20] = 0.0;
    Qux[21] = 0.0;
    Qux[22] = 0.0;
    Qux[23] = 0.0;
    Qux[24] = 0.0;
    Qux[25] = 0.0;
    Qux[26] = t69;
    Qux[27] = c_t111_tmp;
    Qux[28] = t76;
    Qux[29] = t68;
    Qux[30] = 0.0;
    Qux[31] = 0.0;
    Qux[32] = 0.0;
    Qux[33] = 0.0;
    Qux[34] = 0.0;
    Qux[35] = 0.0;
    Qux[36] = t111_tmp;
    Qux[37] = c_A_tmp;
    Qux[38] = t105;
    Qux[39] = t104;
    for (i = 0; i < 4; i++) {
      t111_tmp = 0.0;
      for (i1 = 0; i1 < 10; i1++) {
        t111_tmp += y_tmp[i + (i1 << 2)] * q_N[i1];
      }

      d = 0.0;
      for (i1 = 0; i1 < 24; i1++) {
        d += d_y_tmp[i + (i1 << 2)] * Qx_tmp[i1];
      }

      Qu[i] = t111_tmp + d;
      for (i1 = 0; i1 < 10; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 10; i2++) {
          t111_tmp += y_tmp[i + (i2 << 2)] * V[i2 + 10 * i1];
        }

        c_Quu_tmp[i + (i1 << 2)] = t111_tmp;
      }

      for (i1 = 0; i1 < 24; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 24; i2++) {
          t111_tmp += d_y_tmp[i + (i2 << 2)] * I_mu[i2 + 24 * i1];
        }

        d_Quu_tmp[i + (i1 << 2)] = t111_tmp;
      }

      for (i1 = 0; i1 < 4; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 10; i2++) {
          t111_tmp += c_Quu_tmp[i + (i2 << 2)] * Qux[i2 + 10 * i1];
        }

        j = i + (i1 << 2);
        Quu_tmp[j] = t111_tmp;
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 24; i2++) {
          t111_tmp += d_Quu_tmp[i + (i2 << 2)] * con_u[(i2 + 24 * i1) + 96 *
            (599 - k)];
        }

        b_Quu_tmp[j] = t111_tmp;
      }
    }

    for (i = 0; i < 16; i++) {
      t111_tmp = Quu_tmp[i] + b_Quu_tmp[i];
      Quu_tmp[i] = t111_tmp;
      Quu[i] = t111_tmp + reg[i];
    }

    while (coder::rcond(Quu) < 1.0E-5) {
      std::memset(&reg[0], 0, 16U * sizeof(double));
      reg[0] = 1.0;
      reg[5] = 1.0;
      reg[10] = 1.0;
      reg[15] = 1.0;
      for (i = 0; i < 16; i++) {
        t111_tmp = rho * reg[i];
        reg[i] = t111_tmp;
        Quu[i] = Quu_tmp[i] + t111_tmp;
      }

      rho *= 10.0;

      //          disp(['[backward_pass]: reg increased to ',num2str(rho)]);
    }

    for (i = 0; i < 4; i++) {
      for (i1 = 0; i1 < 10; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 10; i2++) {
          t111_tmp += c_Quu_tmp[i + (i2 << 2)] * A[i2 + 10 * i1];
        }

        b_Qux[i + (i1 << 2)] = t111_tmp;
      }

      for (i1 = 0; i1 < 10; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 24; i2++) {
          t111_tmp += d_Quu_tmp[i + (i2 << 2)] * con_x[(i2 + 24 * i1) + 240 *
            (599 - k)];
        }

        c_Quu_tmp[i + (i1 << 2)] = t111_tmp;
      }
    }

    for (i = 0; i < 40; i++) {
      b_Qux[i] += c_Quu_tmp[i];
    }

    //      Quuh = R_k + B'*(V+reg)*B + cu'*I_mu*cu;
    //
    //      % Regularize the term to be inverted
    //      while rcond(Quuh) < 1e-5
    //          reg = 10.*reg;
    //          Quuh = R_k + B'*(V+reg)*B + cu'*I_mu*cu;
    //      end
    //      Quxh = B'*(V+reg)*A + cu'*I_mu*cx;
    //  Generate Feedback Update
    l[l_tmp] = Qu[0];
    l[l_tmp + 1] = Qu[1];
    l[l_tmp + 2] = Qu[2];
    l[l_tmp + 3] = Qu[3];
    for (i = 0; i < 16; i++) {
      Quu_tmp[i] = -Quu[i];
    }

    coder::internal::reflapack::xzgetrf(Quu_tmp, ipiv, &j);
    if (ipiv[0] != 1) {
      t68 = l[l_tmp];
      j = (ipiv[0] + l_tmp) - 1;
      l[l_tmp] = l[j];
      l[j] = t68;
    }

    if (ipiv[1] != 2) {
      t68 = l[l_tmp + 1];
      j = (ipiv[1] + l_tmp) - 1;
      l[l_tmp + 1] = l[j];
      l[j] = t68;
    }

    if (ipiv[2] != 3) {
      t68 = l[l_tmp + 2];
      j = (ipiv[2] + l_tmp) - 1;
      l[l_tmp + 2] = l[j];
      l[j] = t68;
    }

    if (l[l_tmp] != 0.0) {
      for (y_tmp_tmp = 2; y_tmp_tmp < 5; y_tmp_tmp++) {
        j = (y_tmp_tmp + l_tmp) - 1;
        l[j] -= l[l_tmp] * Quu_tmp[y_tmp_tmp - 1];
      }
    }

    if (l[l_tmp + 1] != 0.0) {
      for (y_tmp_tmp = 3; y_tmp_tmp < 5; y_tmp_tmp++) {
        j = (y_tmp_tmp + ((599 - k) << 2)) - 1;
        l[j] -= l[l_tmp + 1] * Quu_tmp[y_tmp_tmp + 3];
      }
    }

    if (l[l_tmp + 2] != 0.0) {
      j = ((599 - k) << 2) + 3;
      for (y_tmp_tmp = 4; y_tmp_tmp < 5; y_tmp_tmp++) {
        l[j] -= l[l_tmp + 2] * Quu_tmp[11];
      }
    }

    t111_tmp = l[l_tmp + 3];
    if (t111_tmp != 0.0) {
      l[l_tmp + 3] = t111_tmp / Quu_tmp[15];
      for (y_tmp_tmp = 0; y_tmp_tmp < 3; y_tmp_tmp++) {
        j = y_tmp_tmp + l_tmp;
        l[j] -= l[l_tmp + 3] * Quu_tmp[y_tmp_tmp + 12];
      }
    }

    t111_tmp = l[l_tmp + 2];
    if (t111_tmp != 0.0) {
      t111_tmp /= Quu_tmp[10];
      l[l_tmp + 2] = t111_tmp;
      for (y_tmp_tmp = 0; y_tmp_tmp < 2; y_tmp_tmp++) {
        j = y_tmp_tmp + ((599 - k) << 2);
        l[j] -= l[l_tmp + 2] * Quu_tmp[y_tmp_tmp + 8];
      }
    }

    t111_tmp = l[l_tmp + 1];
    if (t111_tmp != 0.0) {
      t111_tmp /= Quu_tmp[5];
      l[l_tmp + 1] = t111_tmp;
      for (y_tmp_tmp = 0; y_tmp_tmp < 1; y_tmp_tmp++) {
        l[l_tmp] -= l[l_tmp + 1] * Quu_tmp[4];
      }
    }

    t111_tmp = l[l_tmp];
    if (t111_tmp != 0.0) {
      l[l_tmp] = t111_tmp / Quu_tmp[0];
    }

    for (i = 0; i < 10; i++) {
      j = i << 2;
      y_tmp_tmp = j + 40 * (599 - k);
      L[y_tmp_tmp] = b_Qux[j];
      L[y_tmp_tmp + 1] = b_Qux[j + 1];
      L[y_tmp_tmp + 2] = b_Qux[j + 2];
      L[y_tmp_tmp + 3] = b_Qux[j + 3];
    }

    for (i = 0; i < 16; i++) {
      b_Quu_tmp[i] = -Quu[i];
    }

    coder::mldivide(b_Quu_tmp, *(double (*)[40])&L[40 * (599 - k)]);

    //  Generate next cost-to-go
    for (i = 0; i < 4; i++) {
      for (i1 = 0; i1 < 10; i1++) {
        Qux[i1 + 10 * i] = b_Qux[i + (i1 << 2)];
      }
    }

    std::memcpy(&y_tmp[0], &Qux[0], 40U * sizeof(double));
    for (i = 0; i < 10; i++) {
      for (i1 = 0; i1 < 10; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 10; i2++) {
          t111_tmp += b_y_tmp[i + 10 * i2] * V[i2 + 10 * i1];
        }

        e_y_tmp[i + 10 * i1] = t111_tmp;
      }

      for (i1 = 0; i1 < 24; i1++) {
        t111_tmp = 0.0;
        for (i2 = 0; i2 < 24; i2++) {
          t111_tmp += c_y_tmp[i + 10 * i2] * I_mu[i2 + 24 * i1];
        }

        f_y_tmp[i + 10 * i1] = t111_tmp;
      }
    }

    i = 40 * (599 - k);
    for (i1 = 0; i1 < 10; i1++) {
      for (i2 = 0; i2 < 10; i2++) {
        t111_tmp = 0.0;
        for (j = 0; j < 10; j++) {
          t111_tmp += e_y_tmp[i1 + 10 * j] * A[j + 10 * i2];
        }

        V[i1 + 10 * i2] = t111_tmp;
      }

      for (i2 = 0; i2 < 10; i2++) {
        t111_tmp = 0.0;
        for (j = 0; j < 24; j++) {
          t111_tmp += f_y_tmp[i1 + 10 * j] * con_x[(j + 24 * i2) + 240 * (599 -
            k)];
        }

        e_y_tmp[i1 + 10 * i2] = t111_tmp;
      }

      i2 = (i1 << 2) + 40 * (599 - k);
      for (j = 0; j < 4; j++) {
        y_tmp_tmp = j << 2;
        Qux[i1 + 10 * j] = ((L[i2] * Quu[y_tmp_tmp] + L[i2 + 1] * Quu[y_tmp_tmp
                             + 1]) + L[i2 + 2] * Quu[y_tmp_tmp + 2]) + L[i2 + 3]
          * Quu[y_tmp_tmp + 3];
      }

      t111_tmp = 0.0;
      d = Qux[i1];
      d1 = Qux[i1 + 10];
      d2 = Qux[i1 + 20];
      t68 = Qux[i1 + 30];
      t70 = y_tmp[i1];
      t69 = y_tmp[i1 + 10];
      d3 = y_tmp[i1 + 20];
      A_tmp = y_tmp[i1 + 30];
      i2 = (i1 << 2) + i;
      for (j = 0; j < 10; j++) {
        int V_tmp;
        int i3;
        int i4;
        y_tmp_tmp = j << 2;
        i3 = y_tmp_tmp + i;
        V_tmp = i1 + 10 * j;
        i4 = y_tmp_tmp + i;
        V[V_tmp] = (((V[V_tmp] + e_y_tmp[V_tmp]) + (((d * L[i3] + d1 * L[i3 + 1])
          + d2 * L[i3 + 2]) + t68 * L[i3 + 3])) + (((L[i2] * b_Qux[y_tmp_tmp] +
          L[i2 + 1] * b_Qux[y_tmp_tmp + 1]) + L[i2 + 2] * b_Qux[y_tmp_tmp + 2])
          + L[i2 + 3] * b_Qux[y_tmp_tmp + 3])) + (((t70 * L[i4] + t69 * L[i4 + 1])
          + d3 * L[i4 + 2]) + A_tmp * L[i4 + 3]);
        t111_tmp += b_y_tmp[V_tmp] * q_N[j];
      }

      d = 0.0;
      for (i2 = 0; i2 < 24; i2++) {
        d += c_y_tmp[i1 + 10 * i2] * Qx_tmp[i2];
      }

      d1 = 0.0;
      d2 = L[(i1 << 2) + 40 * (599 - k)];
      t68 = L[((i1 << 2) + 40 * (599 - k)) + 1];
      t70 = L[((i1 << 2) + 40 * (599 - k)) + 2];
      t69 = L[((i1 << 2) + 40 * (599 - k)) + 3];
      for (i2 = 0; i2 < 4; i2++) {
        j = i2 << 2;
        d1 += (((d2 * Quu[j] + t68 * Quu[j + 1]) + t70 * Quu[j + 2]) + t69 *
               Quu[j + 3]) * l[i2 + l_tmp];
      }

      dv[i1] = (t111_tmp + d) + d1;
      in2[i1] = ((d2 * Qu[0] + t68 * Qu[1]) + t70 * Qu[2]) + t69 * Qu[3];
    }

    t111_tmp = l[l_tmp];
    d = l[l_tmp + 1];
    d1 = l[l_tmp + 2];
    d2 = l[l_tmp + 3];
    for (i = 0; i < 10; i++) {
      q_N[i] = (dv[i] + in2[i]) + (((y_tmp[i] * t111_tmp + y_tmp[i + 10] * d) +
        y_tmp[i + 20] * d1) + y_tmp[i + 30] * d2);
    }

    //  Generate line-search checker
    j = (599 - k) << 1;
    delV[j] = ((l[l_tmp] * Qu[0] + l[l_tmp + 1] * Qu[1]) + l[l_tmp + 2] * Qu[2])
      + l[l_tmp + 3] * Qu[3];
    t68 = 0.0;
    for (i = 0; i < 4; i++) {
      i1 = i << 2;
      t68 += (((l[l_tmp] * Quu[i1] + l[l_tmp + 1] * Quu[i1 + 1]) + l[l_tmp + 2] *
               Quu[i1 + 2]) + l[l_tmp + 3] * Quu[i1 + 3]) * l[i + l_tmp];
    }

    delV[j + 1] = 0.5 * t68;
  }
}

// End of code generation (backward_pass.cpp)
