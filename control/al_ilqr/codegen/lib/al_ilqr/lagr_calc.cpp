//
//  Academic License - for use in teaching, academic research, and meeting
//  course requirements at degree granting institutions only.  Not for
//  government, commercial, or other organizational use.
//
//  lagr_calc.cpp
//
//  Code generation for function 'lagr_calc'
//


// Include files
#include "lagr_calc.h"
#include "rt_nonfinite.h"
#include <cstring>

// Function Definitions
void lagr_calc(const double X[6010], double xs[10], const double con[14424],
               const double lambda[14424], const double mu_diag[14424], double
               J_objs[601], double J_cons[601], double J_tots[601], double
               *J_obj, double *J_con, double *J_tot)
{
  double Xs[6010];
  double t22;
  double t23;
  double t24;
  double t25;
  double t26;
  double t27;
  double t28;
  double t29;
  double t30;
  double t31;
  double t32;
  double t33;
  double t34;
  double t35;
  double t36;
  double t37;
  double t38;
  double t39;
  double t40;
  double t41;
  int i;
  int k;

  //  Initialize Variables
  std::memset(&J_objs[0], 0, 601U * sizeof(double));
  std::memset(&J_cons[0], 0, 601U * sizeof(double));

  //  Initialize the Mex Sensitive Variables
  //  Generate the nominals and ideals (Xstar, Ustar)
  for (i = 0; i < 600; i++) {
    std::memcpy(&Xs[i * 10], &X[i * 10 + 10], 10U * sizeof(double));
  }

  std::memcpy(&Xs[6000], &xs[0], 10U * sizeof(double));

  //  Compute stagewise cost
  //  Terminal Case
  for (k = 0; k < 600; k++) {
    double d;
    double d1;
    double d2;
    double d3;
    int i1;
    int i10;
    int i11;
    int i12;
    int i13;
    int i14;
    int i15;
    int i16;
    int i17;
    int i18;
    int i19;
    int i2;
    int i20;
    int i21;
    int i22;
    int i3;
    int i4;
    int i5;
    int i6;
    int i7;
    int i8;
    int i9;
    J_objs[k] = 0.0;

    // CON_COST
    //     CON_COST = CON_COST(IN1,IN2,IN3)
    //     This function was generated by the Symbolic Math Toolbox version 8.6. 
    //     14-Jul-2021 21:15:56
    t22 = con[24 * k];
    i = 24 * k + 1;
    t23 = con[i];
    i1 = 24 * k + 2;
    t24 = con[i1];
    i2 = 24 * k + 3;
    t25 = con[i2];
    i3 = 24 * k + 4;
    t26 = con[i3];
    i4 = 24 * k + 5;
    t27 = con[i4];
    i5 = 24 * k + 6;
    t28 = con[i5];
    i6 = 24 * k + 7;
    t29 = con[i6];
    i7 = 24 * k + 8;
    t30 = con[i7];
    i8 = 24 * k + 9;
    t31 = con[i8];
    i9 = 24 * k + 10;
    t32 = con[i9];
    i10 = 24 * k + 11;
    t33 = con[i10];
    i11 = 24 * k + 12;
    t34 = con[i11];
    i12 = 24 * k + 13;
    t35 = con[i12];
    i13 = 24 * k + 14;
    t36 = con[i13];
    i14 = 24 * k + 15;
    t37 = con[i14];
    i15 = 24 * k + 16;
    t38 = con[i15];
    i16 = 24 * k + 17;
    t39 = con[i16];
    i17 = 24 * k + 18;
    t40 = con[i17];
    i18 = 24 * k + 19;
    t41 = con[i18];
    i19 = 24 * k + 20;
    d = con[i19];
    i20 = 24 * k + 21;
    d1 = con[i20];
    i21 = 24 * k + 22;
    d2 = con[i21];
    i22 = 24 * k + 23;
    d3 = con[i22];
    J_cons[k] = ((((((((((((((((((((((t22 * (lambda[24 * k] + t22 * mu_diag[24 *
      k] / 2.0) + t23 * (lambda[i] + t23 * mu_diag[i] / 2.0)) + t24 * (lambda[i1]
      + t24 * mu_diag[i1] / 2.0)) + t25 * (lambda[i2] + t25 * mu_diag[i2] / 2.0))
      + t26 * (lambda[i3] + t26 * mu_diag[i3] / 2.0)) + t27 * (lambda[i4] + t27 *
      mu_diag[i4] / 2.0)) + t28 * (lambda[i5] + t28 * mu_diag[i5] / 2.0)) + t29 *
      (lambda[i6] + t29 * mu_diag[i6] / 2.0)) + t30 * (lambda[i7] + t30 *
      mu_diag[i7] / 2.0)) + t31 * (lambda[i8] + t31 * mu_diag[i8] / 2.0)) + t32 *
      (lambda[i9] + t32 * mu_diag[i9] / 2.0)) + t33 * (lambda[i10] + t33 *
      mu_diag[i10] / 2.0)) + t34 * (lambda[i11] + t34 * mu_diag[i11] / 2.0)) +
                          t35 * (lambda[i12] + t35 * mu_diag[i12] / 2.0)) + t36 *
                         (lambda[i13] + t36 * mu_diag[i13] / 2.0)) + t37 *
                        (lambda[i14] + t37 * mu_diag[i14] / 2.0)) + t38 *
                       (lambda[i15] + t38 * mu_diag[i15] / 2.0)) + t39 *
                      (lambda[i16] + t39 * mu_diag[i16] / 2.0)) + t40 *
                     (lambda[i17] + t40 * mu_diag[i17] / 2.0)) + t41 *
                    (lambda[i18] + t41 * mu_diag[i18] / 2.0)) + d * (lambda[i19]
      + d * mu_diag[i19] / 2.0)) + d1 * (lambda[i20] + d1 * mu_diag[i20] / 2.0))
                 + d2 * (lambda[i21] + d2 * mu_diag[i21] / 2.0)) + d3 *
      (lambda[i22] + d3 * mu_diag[i22] / 2.0);
  }

  // OBJ_COST_N
  //     OBJ_COST_N = OBJ_COST_N(IN1,IN2,IN3,IN4,IN5,IN6)
  //     This function was generated by the Symbolic Math Toolbox version 8.6.
  //     14-Jul-2021 21:15:56
  t22 = -X[6000] + X[6000];
  t23 = -X[6001] + X[6001];
  t24 = -X[6002] + X[6002];
  t25 = -X[6003] + X[6003];
  t26 = -X[6004] + X[6004];
  t27 = -X[6005] + X[6005];
  t28 = -X[6006] + X[6006];
  t29 = -X[6007] + X[6007];
  t30 = -X[6008] + X[6008];
  t31 = -X[6009] + X[6009];
  t32 = -Xs[6000] + X[6000];
  t33 = -Xs[6001] + X[6001];
  t34 = -Xs[6002] + X[6002];
  t35 = -Xs[6003] + X[6003];
  t36 = -Xs[6004] + X[6004];
  t37 = -Xs[6005] + X[6005];
  t38 = -Xs[6006] + X[6006];
  t39 = -Xs[6007] + X[6007];
  t40 = -Xs[6008] + X[6008];
  t41 = -Xs[6009] + X[6009];
  J_objs[600] = ((((((((((((((((((((((((((((t22 * t32 + t23 * t33) + t24 * t34)
    + t25 * t35) + t26 * t36) + t27 * t37) + t28 * t38) + t29 * t39) + t30 * t40)
    + t31 * t41) + t22 * t22) + t23 * t23) + t24 * t24) + t25 * t25) + t26 * t26)
    + t27 * t27) + t28 * t28) + t29 * t29) + t30 * t30) + t31 * t31) + t32 * (X
    [6000] / 2.0 - xs[0] / 2.0)) + t33 * (X[6001] / 2.0 - xs[1] / 2.0)) + t34 *
                       (X[6002] / 2.0 - xs[2] / 2.0)) + t35 * (X[6003] / 2.0 -
    xs[3] / 2.0)) + t36 * (X[6004] / 2.0 - xs[4] / 2.0)) + t37 * (X[6005] / 2.0
    - xs[5] / 2.0)) + t38 * (X[6006] / 2.0 - xs[6] / 2.0)) + t39 * (X[6007] /
    2.0 - xs[7] / 2.0)) + t40 * (X[6008] / 2.0 - xs[8] / 2.0)) + t41 * (X[6009] /
    2.0 - xs[9] / 2.0);

  // CON_COST
  //     CON_COST = CON_COST(IN1,IN2,IN3)
  //     This function was generated by the Symbolic Math Toolbox version 8.6.
  //     14-Jul-2021 21:15:56
  J_cons[600] = ((((((((((((((((((((((con[14400] * (lambda[14400] + con[14400] *
    mu_diag[14400] / 2.0) + con[14401] * (lambda[14401] + con[14401] * mu_diag
    [14401] / 2.0)) + con[14402] * (lambda[14402] + con[14402] * mu_diag[14402] /
    2.0)) + con[14403] * (lambda[14403] + con[14403] * mu_diag[14403] / 2.0)) +
    con[14404] * (lambda[14404] + con[14404] * mu_diag[14404] / 2.0)) + con
    [14405] * (lambda[14405] + con[14405] * mu_diag[14405] / 2.0)) + con[14406] *
    (lambda[14406] + con[14406] * mu_diag[14406] / 2.0)) + con[14407] * (lambda
    [14407] + con[14407] * mu_diag[14407] / 2.0)) + con[14408] * (lambda[14408]
    + con[14408] * mu_diag[14408] / 2.0)) + con[14409] * (lambda[14409] + con
    [14409] * mu_diag[14409] / 2.0)) + con[14410] * (lambda[14410] + con[14410] *
    mu_diag[14410] / 2.0)) + con[14411] * (lambda[14411] + con[14411] * mu_diag
    [14411] / 2.0)) + con[14412] * (lambda[14412] + con[14412] * mu_diag[14412] /
    2.0)) + con[14413] * (lambda[14413] + con[14413] * mu_diag[14413] / 2.0)) +
    con[14414] * (lambda[14414] + con[14414] * mu_diag[14414] / 2.0)) + con
                        [14415] * (lambda[14415] + con[14415] * mu_diag[14415] /
    2.0)) + con[14416] * (lambda[14416] + con[14416] * mu_diag[14416] / 2.0)) +
                      con[14417] * (lambda[14417] + con[14417] * mu_diag[14417] /
    2.0)) + con[14418] * (lambda[14418] + con[14418] * mu_diag[14418] / 2.0)) +
                    con[14419] * (lambda[14419] + con[14419] * mu_diag[14419] /
    2.0)) + con[14420] * (lambda[14420] + con[14420] * mu_diag[14420] / 2.0)) +
                  con[14421] * (lambda[14421] + con[14421] * mu_diag[14421] /
    2.0)) + con[14422] * (lambda[14422] + con[14422] * mu_diag[14422] / 2.0)) +
    con[14423] * (lambda[14423] + con[14423] * mu_diag[14423] / 2.0);

  //  Totals
  for (i = 0; i < 601; i++) {
    J_tots[i] = J_objs[i] + J_cons[i];
  }

  *J_obj = J_objs[0];
  *J_con = J_cons[0];
  for (k = 0; k < 600; k++) {
    *J_obj += J_objs[k + 1];
    *J_con += J_cons[k + 1];
  }

  *J_tot = *J_obj + *J_con;

  //  disp(['[lagr_calc]: Obj. Cost: ',num2str(J.obj),' Con. Cost: ',num2str(J.con)]); 
}

// End of code generation (lagr_calc.cpp)
